var pWorker = (function (pEnv) {
    var m_pPost = pEnv.postMessage;
    var m_aWait = [];
    var m_pLoadMapbox = MapboxLoader();
    var pTextDecoder = new TextDecoder('utf-8');
    var m_nStartTime = Date.now();
    var m_pMemory = new WebAssembly.Memory({ initial: 64 * 16, maximum: 32768 });
    var m_pHeap = {
        WriteArrayBuffer: function (nAddr, pData) {
            this.m_pU8.set(new Uint8Array(pData), nAddr);
        },
        WriteFloat32Array: function (nAddr, aData) {
            this.m_pF32.set(aData, nAddr / 4);
        },
        ReadU32: function (nAddr, nCount) {
            return this.m_pU32.subarray(nAddr / 4, nAddr / 4 + nCount);
        },
        SliceU8: function (nAddr, nCount) {
            return this.m_pU8.slice(nAddr, nAddr + nCount);
        },
        m_pU8: new Uint8Array(m_pMemory.buffer),
        m_pU32: new Uint32Array(m_pMemory.buffer),
        m_pF32: new Float32Array(m_pMemory.buffer)
    };
    var m_aFuncLut = null;
    var m_pFunc = {
        env: {
            "memory": m_pMemory,
            "APP_PLUGIN_TYPE": function () {
                return 2;
            },
            "APP_MEM_TYPE": function () {
                return 1;
            },
            "APP_MEM_RESERVE": function () {
                return 1024;
            },
            "APP_MEM_BASE": function () {
                console.error("子线程不支持使用线性内存!");
                return 0;
            },
            "APP_MEM_GROW": function (nSize) {
                console.error("子线程不支持使用线性内存!");
            },
            "APP_MEM_RECYCLE": function (nSize) {
                console.error("子线程不支持使用线性内存!");
            },
            "APP_MEM_MALLOC": function (nSize) {
                console.error("子线程仅允许使用60M内存!");
                return 0;
            },
            "APP_MEM_FREE": function (nPtr) {
                console.error("子线程不允许回收固定内存!");
            },
            "APP_PRINT": function (nMsgAddr, nMsgSize, nCtrl) {
                var aChar = m_pHeap.m_pU8.subarray(nMsgAddr, nMsgAddr + nMsgSize);
                var pMsg = pTextDecoder.decode(aChar);
                if (2 === nCtrl) {
                    console.warn("Worker:", (Date.now() - m_nStartTime), pMsg);
                }
                else if (2 < nCtrl) {
                    console.error("Worker:", (Date.now() - m_nStartTime), pMsg);
                }
                else {
                    console.info("Worker:", (Date.now() - m_nStartTime), pMsg);
                }
            }
        }
    };
    pEnv.onmessage = function (pEvent) {
        var pData = pEvent.data;
        if (m_aWait) {
            if (1 === pData.m_nID) {
                Init(pData.m_aCode, function () {
                    m_pPost({
                        m_nID: 1,
                        m_aDict: ["1:INIT", "2:LOAD_TERRAIN", "3:LOAD_MAPBOX"]
                    });
                    var aWait = m_aWait;
                    m_aWait = null;
                    for (var _i = 0, aWait_1 = aWait; _i < aWait_1.length; _i++) {
                        var pEvent_ = aWait_1[_i];
                        pEnv.onmessage(pEvent_);
                    }
                });
                return;
            }
            m_aWait.push(pEvent);
            return;
        }
        switch (pData.m_nID) {
            case 2:
                LoadTerrain(pData);
                break;
            case 3:
                m_pLoadMapbox(pData);
                break;
            case 4:
                Load3MX(pData);
                break;
            default:
                console.error("主线程消息异常:", pData);
                break;
        }
    };
    function Load3MX(pEvent) {
        var pPath = pEvent.m_pPath;
        var pPath_ = pPath;
        var nNewFolder = pEvent.m_nNewFolder;
        if (!pPath_.startsWith("http")) {
            pPath_ = "../../" + pPath_;
        }
        Fetch(pPath_, function (aData) {
            if (!aData) {
                return;
            }
            var aMeta = new Uint32Array(aData, 0, 2);
            if (0x42584D33 === aMeta[0]) {
                var nHeaderSize = aMeta[1] >> 8;
                var nDataAddr = 9 + nHeaderSize;
                var nDataSize = aData.byteLength - nDataAddr;
                var aHeader = new Uint8Array(aData, 9, nHeaderSize);
                var pHeader = pTextDecoder.decode(aHeader);
                var jHeader = JSON.parse(pHeader);
                var pFolder = {
                    m_pPath: pPath.substring(0, (pPath.lastIndexOf("/") + 1)),
                    m_aFile: []
                };
                var tRes = [];
                var oRes = [];
                var iRes = jHeader.resources;
                var nOffset = 0;
                for (var i = 0; i < iRes.length; i++) {
                    tRes.push(i);
                    if ("textureBuffer" === iRes[i].type) {
                        tRes.push(0);
                        oRes.push(i);
                        if ("jpg" === iRes[i].format) {
                            tRes.push(0);
                        }
                        else if ("png" === iRes[i].format) {
                            tRes.push(1);
                        }
                        else {
                            tRes.push(10000);
                        }
                    }
                    else if ("geometryBuffer" === iRes[i].type) {
                        tRes.push(1);
                        if ("ctm" === iRes[i].format) {
                            tRes.push(0);
                        }
                        else {
                            tRes.push(10000);
                        }
                    }
                    else {
                        tRes.push(10000);
                        tRes.push(10000);
                    }
                    tRes.push(iRes[i].size);
                    tRes.push(nOffset);
                    nOffset += iRes[i].size;
                    tRes.push(10000);
                    if (iRes[i].texture) {
                        for (var j = 0; j < iRes.length; j++) {
                            if (iRes[i].texture === iRes[j].id) {
                                tRes[tRes.length - 1] = j;
                                break;
                            }
                        }
                    }
                }
                var oNode = [];
                var iNode = jHeader.nodes;
                for (var i = 0; i < iNode.length; i++) {
                    var pNode = iNode[i];
                    var xLen = pNode.bbMax[0] - pNode.bbMin[0];
                    var yLen = pNode.bbMax[1] - pNode.bbMin[1];
                    var zLen = pNode.bbMax[2] - pNode.bbMin[2];
                    var nLen = Math.sqrt(xLen * xLen + yLen * yLen + zLen * zLen);
                    oNode.push(Math.floor(parseInt(pNode.bbMin[0] + pNode.bbMax[0]) * 0.5 * 100.0));
                    oNode.push(Math.floor(parseInt(pNode.bbMin[1] + pNode.bbMax[1]) * 0.5 * 100.0));
                    oNode.push(Math.floor(parseInt(pNode.bbMin[2] + pNode.bbMax[2]) * 0.5 * 100.0));
                    oNode.push(Math.floor(nLen * 100.0) * 1024 + zLen);
                    oNode.push(Math.floor(pNode.maxScreenDiameter));
                    var nSubCount = pNode.children ? pNode.children.length : 0;
                    if (0 < nSubCount) {
                        oNode.push(pFolder.m_aFile.length);
                        for (var j = 0; j < nSubCount; j++) {
                            pFolder.m_aFile.push(pNode.children[j]);
                        }
                        oNode.push(pFolder.m_aFile.length);
                    }
                    else {
                        oNode.push(-1);
                        oNode.push(-1);
                    }
                    var nResCount = pNode.resources ? pNode.resources.length : 0;
                    if (0 < nResCount) {
                        oNode.push(oRes.length);
                        for (var j = 0; j < nResCount; j++) {
                            for (var k = 0; k < iRes.length; k++) {
                                if (pNode.resources[j] === iRes[k].id) {
                                    oRes.push(k);
                                    break;
                                }
                            }
                        }
                        oNode.push(oRes.length);
                    }
                    else {
                        oNode.push(-1);
                        oNode.push(-1);
                    }
                }
                var nDescNum = 4 + (9 * iNode.length) + (6 * oRes.length);
                var nDescSize = 4 * nDescNum;
                var oDesc = new Int32Array(nDescNum);
                var oData = [oDesc.buffer];
                {
                    oDesc[0] = nDescSize;
                    oDesc[1] = iNode.length;
                    oDesc[2] = oRes.length;
                    oDesc[3] = nNewFolder;
                    oDesc.set(oNode, 4);
                    var nIndex = 4 + oNode.length;
                    for (var i = 0; i < oRes.length; i++) {
                        var nIndex2 = 6 * oRes[i];
                        for (var j = 0; j < 6; j++) {
                            oDesc[nIndex++] = tRes[nIndex2++];
                        }
                        var nIndex3 = nIndex - 6;
                        {
                            var nType_ = oDesc[nIndex3 + 1];
                            var nAddr_ = nDataAddr + oDesc[nIndex3 + 4];
                            var nSize_ = oDesc[nIndex3 + 3];
                            var pData_ = aData.slice(nAddr_, nAddr_ + nSize_);
                            if (0 === nType_) {
                                oData.push(pData_);
                            }
                            else if (1 === nType_) {
                                var nBufferAddr = m_pFunc.UTIL_BUFFER(nSize_);
                                m_pHeap.WriteArrayBuffer(nBufferAddr, pData_);
                                nBufferAddr = m_pFunc.UTIL_DECODE_CTM(nBufferAddr, nSize_);
                                if (0 < nBufferAddr) {
                                    var aRef = m_pHeap.ReadU32(nBufferAddr, 2);
                                    pData_ = m_pMemory.buffer.slice(aRef[0], aRef[0] + aRef[1]);
                                    oData.push(pData_);
                                }
                                else {
                                    oData.push(null);
                                }
                            }
                            else {
                                oData.push(null);
                            }
                        }
                    }
                }
                pEvent.m_pNewFolder = pFolder;
                pEvent.m_pData = oData;
                m_pPost(pEvent, oData);
            }
        });
    }
    function LoadTerrain(pEvent) {
        Fetch(pEvent.m_pPath, function (pData) {
            if (!pData || 152 === pData.byteLength) {
                pEvent.m_pData = null;
                m_pPost(pEvent);
                return;
            }
            var nSize = pData.byteLength;
            var nAddr = m_pFunc.UTIL_BUFFER(nSize);
            var aOut = null;
            if (0 < nAddr) {
                m_pHeap.WriteArrayBuffer(nAddr, pData);
                nAddr = m_pFunc.UTIL_DECODE_TERRAIN(nAddr, nSize);
                if (0 < nAddr) {
                    var aRef = m_pHeap.ReadU32(nAddr, 2);
                    aOut = m_pHeap.SliceU8(aRef[0], aRef[1]).buffer;
                }
            }
            if (aOut) {
                pEvent.m_pData = aOut;
                m_pPost(pEvent, [aOut]);
            }
            else {
                pEvent.m_pData = null;
                m_pPost(pEvent);
            }
        });
    }
    function MapboxLoader() {
        var LoadMapboxTile = Mapbox();
        var aQueue = [];
        var bDoing = false;
        var LoadMapboxEnd = function (nDesc) {
            var pEvent = aQueue.shift();
            var aTransfer = [];
            var aOut = [];
            var aDesc = m_pHeap.ReadU32(nDesc, 28);
            for (var i = 0; i < 4; i++) {
                var nIndex = 7 * i;
                var pMesh = {
                    m_nVertexCount: aDesc[nIndex + 0],
                    m_nInputCount: aDesc[nIndex + 1],
                    m_nSubmeshCount: aDesc[nIndex + 2],
                    m_aPosition: null,
                    m_aNormal: null,
                    m_aUV: null,
                    m_aIndex: null
                };
                if (0 < pMesh.m_nVertexCount && 0 < pMesh.m_nSubmeshCount) {
                    pMesh.m_aPosition = m_pHeap.SliceU8(aDesc[nIndex + 3], 12 * pMesh.m_nVertexCount).buffer;
                    pMesh.m_aNormal = m_pHeap.SliceU8(aDesc[nIndex + 4], 12 * pMesh.m_nVertexCount).buffer;
                    pMesh.m_aUV = m_pHeap.SliceU8(aDesc[nIndex + 5], 8 * pMesh.m_nVertexCount).buffer;
                    pMesh.m_aIndex = m_pHeap.SliceU8(aDesc[nIndex + 6], 8 * pMesh.m_nSubmeshCount).buffer;
                    aTransfer.push(pMesh.m_aPosition);
                    aTransfer.push(pMesh.m_aNormal);
                    aTransfer.push(pMesh.m_aUV);
                    aTransfer.push(pMesh.m_aIndex);
                }
                aOut.push(pMesh);
            }
            pEvent.m_pData = aOut;
            m_pPost(pEvent, aTransfer);
            bDoing = false;
        };
        var LoadBlockbox = function (nCol, nRow, nColOffset, nRowOffset) {
            m_pFunc.UTIL_DECODE_MAPBOX_BLOCK_START(16);
            var _loop_1 = function (i) {
                var _loop_2 = function (j) {
                    LoadMapboxTile(nCol + j, nRow + i, 18, function (pData) {
                        var nAddr = 0;
                        var nCount = 0;
                        if (pData) {
                            var nSize = 4 * pData.m_aData.length;
                            nAddr = m_pFunc.UTIL_BUFFER(nSize);
                            if (nAddr) {
                                m_pHeap.WriteFloat32Array(nAddr, pData.m_aData);
                                nCount = pData.m_nCount;
                            }
                        }
                        var nBlock = m_pFunc.UTIL_DECODE_MAPBOX_BLOCK_FILL(nColOffset, nRowOffset, 4 * i + j, nCount, nAddr);
                        if (nBlock) {
                            LoadMapboxEnd(nBlock);
                        }
                    });
                };
                for (var j = 0; j < 4; j++) {
                    _loop_2(j);
                }
            };
            for (var i = 0; i < 4; i++) {
                _loop_1(i);
            }
        };
        return function (pEvent) {
            aQueue.push(pEvent);
            if (!bDoing) {
                bDoing = true;
                pEvent = aQueue[0];
                LoadBlockbox(pEvent.m_nCol, pEvent.m_nRow, pEvent.m_nColOffset, pEvent.m_nRowOffset);
            }
        };
    }
    function Fetch(pPath, pCallback) {
        fetch(pPath)
            .then(function (pResponse) { return pResponse.arrayBuffer(); })
            .then(function (pBuffer) {
            if (null !== pBuffer) {
                pCallback(pBuffer);
            }
            else {
                console.error("Fetch null: ", pPath);
                pCallback(null);
            }
        }).catch(function (e) {
            console.error("Fetch error: ", pPath, e);
        });
    }
    function Init(pBlob, pCallback) {
        WebAssembly.instantiate(pBlob, m_pFunc)
            .then(function (pModule_) { return pModule_.instance; })
            .then(function (pInstance) {
            m_pFunc = pInstance.exports;
            m_aFuncLut = pInstance.exports.__indirect_function_table;
            pCallback();
        })
            .catch(function (e) {
            console.error("WebAssembly.instantiate error:", e);
        });
    }
})(this);
function Mapbox() {
    var POLYGON_STYLE = 5;
    var POLYGON3D_STYLE = 6;
    var aServer = [
        "https://ss0.bdstatic.com/8bo_dTSlR1gBo1vgoIiO_jowehsv",
        "https://ss1.bdstatic.com/8bo_dTSlR1gBo1vgoIiO_jowehsv",
        "https://ss2.bdstatic.com/8bo_dTSlR1gBo1vgoIiO_jowehsv",
        "https://ss3.bdstatic.com/8bo_dTSlR1gBo1vgoIiO_jowehsv"
    ];
    var aOriginServer = ["https://pcor.baidu.com/"];
    var pVersion = "001";
    var pUdt = "20190919";
    var nPixelRatio = 1;
    var pFeatureStyle = undefined;
    var pWaite = [];
    function Fetch(pPath, pCallback) {
        fetch(pPath)
            .then(function (pResponse) { return pResponse.text(); })
            .then(function (pBuffer) {
            if (null !== pBuffer) {
                pCallback(pBuffer);
            }
            else {
                console.error("Fetch null: ", pPath);
            }
        }).catch(function (e) {
            console.error("Fetch error: ", pPath, e);
        });
    }
    function LoadFS(pCallback) {
        var pUrl = aServer[0] + "/sty/vpl.js?udt=" + pUdt + "&v=" + pVersion;
        Fetch(pUrl, function (aData) {
            pFeatureStyle = eval(aData.substring(20));
            pCallback();
        });
    }
    function LoadVectorTileData(nCol, nRow, nLevel, pCallback) {
        var pKey = GetTileKey(nCol, nRow, nLevel);
        var pUrl = GetTilesUrl(nCol, nRow, nLevel);
        if (!pFeatureStyle) {
            if (undefined === pFeatureStyle) {
                pFeatureStyle = null;
                LoadFS(function () {
                    for (var _i = 0, pWaite_1 = pWaite; _i < pWaite_1.length; _i++) {
                        var func = pWaite_1[_i];
                        func();
                    }
                });
            }
            pWaite.push(function () {
                Fetch(pUrl, function (aData) {
                    pCallback(pKey, aData);
                });
            });
        }
        else {
            Fetch(pUrl, function (aData) {
                pCallback(pKey, aData);
            });
        }
    }
    function GetTileKey(nCol, nRow, nLevel) {
        return "B_NORMAL_MAP" + "_" + nCol + "_" + nRow + "_" + nLevel;
    }
    function GetTilesUrl(nCol_, nRow_, nLeve_) {
        var nCol = CalcLoopParam(nCol_, nLeve_);
        var nRow = nRow_;
        var nPath = Math.abs(nCol + nRow) % aServer.length;
        var pPath = aServer[nPath];
        if (2 === Math.abs(nCol + nRow) % 3) {
            pPath = aOriginServer[0];
        }
        var nLimit = (nLeve_ >= 3 && 9 >= nLeve_) ? 100 : 80;
        var pScaler = nPixelRatio > 1 ? "&scaler=2" : "";
        var pParam = "x=" + nCol + "&y=" + nRow + "&z=" + nLeve_;
        pParam += "&styles=pl&p=0&cm=1&limit=" + nLimit + pScaler + "&udt=" + pUdt + "&v=" + pVersion;
        var pUrl = pPath + "/pvd/?qt=tile" + "&param=" + EncodeUrl(pParam);
        return pUrl;
    }
    function CalcLoopParam(nCol, nLevel) {
        var nCount = 6 * Math.pow(2, nLevel - 3);
        var nStart = -nCount / 2;
        var nEnd = nCount / 2 - 1;
        for (; nCol > nEnd;) {
            nCol -= nCount;
        }
        for (; nStart > nCol;) {
            nCol += nCount;
        }
        return nCol;
    }
    function EncodeUrl(pUrl) {
        var pBinaryUrl = "";
        for (var i = 0; i < pUrl.length; i++) {
            var nChar = pUrl.charCodeAt(i) << 1;
            var pBinary = nChar.toString(2);
            var pBinary8 = pBinary;
            if (8 > pBinary.length) {
                pBinary8 = "00000000" + pBinary;
                pBinary8 = pBinary8.substr(pBinary.length, 8);
            }
            pBinaryUrl += pBinary8;
        }
        var nGap = 5 - pBinaryUrl.length % 5;
        var pAppend = "";
        for (var i = 0; i < nGap; i++) {
            pAppend += "0";
        }
        pBinaryUrl = pAppend + pBinaryUrl;
        var pOut = "";
        for (var i = 0; i < pBinaryUrl.length / 5; i++) {
            var pSubstring = pBinaryUrl.substr(5 * i, 5);
            var nCode = parseInt(pSubstring, 2) + 50;
            var nChar = String.fromCharCode(nCode);
            pOut += nChar;
        }
        return pOut + nGap;
    }
    function ParseData(pData, nLevel) {
        var jData = undefined;
        eval("jData = " + pData);
        return ParseRegion(jData, nLevel);
    }
    function ParseRegion(jData, nLevel) {
        var aData = [];
        var nCount = 0;
        var jRegionList = jData[2];
        var jRoadList = jData[6];
        if (jRegionList) {
            for (var i = 0; i < jRegionList.length; i++) {
                var jRegion = jRegionList[i];
                var jFStyle = pFeatureStyle[jRegion[5]];
                if (18 <= nLevel && POLYGON3D_STYLE === jFStyle[0]) {
                    var pID = jRegion[1];
                    var nHeight = jRegion[3] * Math.pow(2, nLevel - 18);
                    aData.push(0.0);
                    aData.push(1.0);
                    aData.push(1.0);
                    aData.push(1.0);
                    aData.push(1.0);
                    aData.push(1.0);
                    aData.push(nHeight);
                    ParseFeature(jRegion, "Building", aData);
                    nCount++;
                }
                else if (POLYGON_STYLE === jFStyle[0]) {
                    if (jRegion[4] && "090301" === jRegion[4].toString()) {
                        continue;
                    }
                    var pColor = jFStyle[1];
                    var aColor = pColor.split(',');
                    aData.push(0.0);
                    aData.push(2.0);
                    aData.push(parseInt(aColor[0]));
                    aData.push(parseInt(aColor[1]));
                    aData.push(parseInt(aColor[2]));
                    aData.push(parseInt(aColor[3]));
                    aData.push(0.0);
                    ParseFeature(jRegion, "Area", aData);
                    nCount++;
                }
            }
        }
        if (jRoadList) {
            for (var i = 0; i < jRoadList.length; i++) {
                var jRegion = jRoadList[i];
                var jFStyle = pFeatureStyle[jRegion[5]];
                var pColor = jFStyle[1];
                var aColor = pColor.split(',');
                aData.push(0.0);
                aData.push(3.0);
                aData.push(parseInt(aColor[0]));
                aData.push(parseInt(aColor[1]));
                aData.push(parseInt(aColor[2]));
                aData.push(parseInt(aColor[3]));
                aData.push(0.0);
                ParseFeature(jRegion, "Road", aData);
                nCount++;
            }
        }
        return { m_nCount: nCount, m_aData: aData };
    }
    function ParseFeature(jRegion, pType, aData) {
        var jPolygon = jRegion[0];
        var x = 0.0;
        var z = 0.0;
        aData.push(jPolygon.length);
        if ("Building" === pType) {
            for (var i = 0; i < jPolygon.length; i++) {
                x += jPolygon[i][0] / 10;
                z += jPolygon[i][1] / 10;
                aData.push(x);
                aData.push(0.0);
                aData.push(z);
            }
        }
        else if ("Area" === pType || "Road" === pType) {
            for (var i = 0; i < jPolygon.length; i++) {
                x += jPolygon[i][0] / 10;
                z += jPolygon[i][1] / 10;
                aData.push(x);
                aData.push(0.0);
                aData.push(z);
            }
        }
    }
    function LoadBdmapTile(nCol, nRow, nLevel, pCallback) {
        LoadVectorTileData(nCol, nRow, nLevel, function (pKey, pText) {
            if (pText) {
                var pData = ParseData(pText, nLevel);
                pCallback(pData);
            }
            else {
                pCallback(null);
            }
        });
    }
    return LoadBdmapTile;
}
